import os
import re
import asyncio
import logging
import sqlite3
import random
from datetime import datetime, timedelta, timezone
from zoneinfo import ZoneInfo

from aiogram import Bot, Dispatcher, F
from aiogram.filters import CommandStart, Command
from aiogram.types import (
    Message,
    CallbackQuery,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
)
from aiogram.exceptions import TelegramForbiddenError, TelegramBadRequest
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext

# =========================
# –ù–ê–°–¢–†–û–ô–ö–ò –ß–ï–†–ï–ó ENV
# =========================
BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
APP_URL = os.getenv("APP_URL", "").strip()
DB_PATH = os.getenv("DB_PATH", "/opt/compass/web/compass.db").strip()

DEFAULT_TZ = os.getenv("DEFAULT_TZ", "Europe/Moscow").strip()
POLL_INTERVAL_SEC = int(os.getenv("POLL_INTERVAL_SEC", "20"))

if not BOT_TOKEN:
    raise RuntimeError("–ù–µ –∑–∞–¥–∞–Ω BOT_TOKEN")
if not APP_URL:
    raise RuntimeError("–ù–µ –∑–∞–¥–∞–Ω APP_URL (—Å—Å—ã–ª–∫–∞ –Ω–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ COMPASS)")

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
log = logging.getLogger("compass_tg_bot")

# =========================
# –¢–ï–ö–°–¢–´ –°–û–û–ë–©–ï–ù–ò–ô
# =========================
MSG_START_REGISTERED = (
    "–í—ã –≤ —Å–∏—Å—Ç–µ–º–µ.\n"
    "–û—Ç–∫—Ä—ã–≤–∞–π—Ç–µ COMPASS –ø–æ –∫–Ω–æ–ø–∫–µ –Ω–∏–∂–µ.\n"
    "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: /notifications"
)
MSG_START_NOT_REGISTERED = (
    "–ü–æ—Ö–æ–∂–µ, –≤—ã –µ—â—ë –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ COMPASS.\n"
    "–û—Ç–∫—Ä–æ–π—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, –ø—Ä–æ–π–¥–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∏ –≤–µ—Ä–Ω–∏—Ç–µ—Å—å —Å—é–¥–∞."
)
MSG_MYTIME_NOT_FOUND = "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –°–Ω–∞—á–∞–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –≤ COMPASS –∏ –Ω–∞–∂–º–∏—Ç–µ /start."

MSG_CHECKIN_REMINDER = "–ß–µ–∫-–∏–Ω: –æ—Ç–º–µ—Ç—å—Ç–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤ COMPASS."
MSG_CHECKOUT_REMINDER = "–ß–µ–∫-–∞—É—Ç: –∑–∞—Ñ–∏–∫—Å–∏—Ä—É–π—Ç–µ –∏—Ç–æ–≥ –¥–Ω—è –≤ COMPASS."

MSG_NOTIFY_HEADER = "–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π."
MSG_NOTIFY_TIME_PROMPT = "–í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ HH:MM (–Ω–∞–ø—Ä–∏–º–µ—Ä 09:30)."
MSG_NOTIFY_BAD_TIME = "–ù–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ HH:MM. –ü—Ä–∏–º–µ—Ä: 09:30"
MSG_NOTIFY_DB_ERROR = "–ù–µ –º–æ–≥—É –ø—Ä–æ—á–∏—Ç–∞—Ç—å/–∑–∞–ø–∏—Å–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (–æ—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö)."

# =========================
# –®–ê–ë–õ–û–ù–´ –¢–ï–ö–°–¢–û–í –£–í–ï–î–û–ú–õ–ï–ù–ò–ô (—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ –∑–¥–µ—Å—å)
# =========================
# –ò–¥–µ—è: —á–µ–º –±–ª–∏–∂–µ –∫ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—é –∞—Å–∫–µ–∑—ã, —Ç–µ–º –±–æ–ª–µ–µ –ø–æ–¥–±–∞–¥—Ä–∏–≤–∞—é—â–∏–µ —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∏.
# –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–ª—è—Ç—å/—É–¥–∞–ª—è—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã ~ –±–æ—Ç –±—É–¥–µ—Ç –≤—ã–±–∏—Ä–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–π.

# –ß–ï–ö-–ò–ù / –ß–ï–ö-–ê–£–¢ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
CHECKIN_TEMPLATES = [
    "‚è∞ –í—Ä–µ–º—è –∫–æ—Ä–æ—Ç–∫–æ–≥–æ —á–µ–∫-–∏–Ω–∞. –ö–∞–∫ –≤—ã —Å–µ–π—á–∞—Å?",
    "üåø –ü–∞—É–∑–∞ –Ω–∞ –º–∏–Ω—É—Ç—É: –æ—Ç–º–µ—Ç—å—Ç–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤ COMPASS.",
    "üß≠ –ó–∞–≥–ª—è–Ω–∏—Ç–µ –≤–Ω—É—Ç—Ä—å: —á–µ–∫-–∏–Ω –∂–¥—ë—Ç –≤–∞—Å –≤ COMPASS.",
]

CHECKOUT_TEMPLATES = [
    "üåô –ü–æ–¥–≤–µ–¥–∏—Ç–µ –∏—Ç–æ–≥ –¥–Ω—è –≤ COMPASS. –î–∞–∂–µ –ø–∞—Ä–∞ —Å–ª–æ–≤ ~ —É–∂–µ –∑–∞–±–æ—Ç–∞ –æ —Å–µ–±–µ.",
    "‚ú® –ß–µ–∫-–∞—É—Ç: –∑–∞—Ñ–∏–∫—Å–∏—Ä—É–π—Ç–µ, –∫–∞–∫ –ø—Ä–æ—à—ë–ª –¥–µ–Ω—å.",
    "üß© –°–æ–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å –≤ –æ–¥–Ω—É –º—ã—Å–ª—å: —á–µ–∫-–∞—É—Ç –≤ COMPASS.",
]

# –ê–°–ö–ï–ó–´
ASKEZA_TEMPLATES = {
    # –Ω–∞—á–∞–ª–æ/–ø–µ—Ä–≤—ã–µ –¥–Ω–∏
    "start": [
        "üöÄ –û—Ç–ª–∏—á–Ω—ã–π —Å—Ç–∞—Ä—Ç. –ú–∞–ª–µ–Ω—å–∫–∏–π —à–∞–≥ —Å–µ–≥–æ–¥–Ω—è = –±–æ–ª—å—à–∞—è –ø—Ä–∏–≤—ã—á–∫–∞ –∑–∞–≤—Ç—Ä–∞.",
        "üî• –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º! –ì–ª–∞–≤–Ω–æ–µ ~ –Ω–µ —Å–∫–æ—Ä–æ—Å—Ç—å, –∞ —Ä–µ–≥—É–ª—è—Ä–Ω–æ—Å—Ç—å.",
        "üå± –ó–∞–∫–ª–∞–¥—ã–≤–∞–µ—Ç–µ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç. –î–µ—Ä–∂–∏–º –∫—É—Ä—Å!",
    ],
    # —Å–µ—Ä–µ–¥–∏–Ω–∞
    "middle": [
        "üí™ –≠—Ç–æ —É–∂–µ –Ω–µ –≤–¥–æ—Ö–Ω–æ–≤–µ–Ω–∏–µ, —ç—Ç–æ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞. –í—ã –∫—Ä—É—Ç—ã.",
        "üß† –ü—Ä–∏–≤—ã—á–∫–∞ —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å. –ï—â—ë –Ω–µ–º–Ω–æ–≥–æ ~ –∏ —Å—Ç–∞–Ω–µ—Ç –ª–µ–≥—á–µ.",
        "üåä –í —Å–µ—Ä–µ–¥–∏–Ω–µ –ø—É—Ç–∏ —á–∞—Å—Ç–æ —Ç–∏—Ö–æ. –ò —ç—Ç–æ –∑–Ω–∞—á–∏—Ç: –≤—ã –¥–µ–ª–∞–µ—Ç–µ –¥–µ–ª–æ.",
    ],
    # –±–ª–∏–∑–∫–æ –∫ —Ñ–∏–Ω–∏—à—É
    "almost": [
        "üèÅ –§–∏–Ω–∏—à —É–∂–µ –≤–∏–¥–µ–Ω! –ù–µ –æ—Ç–¥–∞–≤–∞–π—Ç–µ –ø–æ–±–µ–¥—É –∑–∞ —à–∞–≥ –¥–æ –Ω–µ—ë.",
        "‚ö° –°–æ–≤—Å–µ–º —á—É—Ç—å-—á—É—Ç—å. –î–æ–≤–µ–¥–∏—Ç–µ –¥–æ –∫—Ä–∞—Å–∏–≤–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.",
        "üéØ –í—ã –ø–æ—á—Ç–∏ —É —Ü–µ–ª–∏. –°–µ–≥–æ–¥–Ω—è—à–Ω–∏–π —à–∞–≥ –æ—Å–æ–±–µ–Ω–Ω–æ –≤–∞–∂–µ–Ω.",
    ],
    # –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–µ–Ω—å/—Ñ–∏–Ω–∞–ª
    "final": [
        "ü•á –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä—ã–≤–æ–∫! –°–µ–≥–æ–¥–Ω—è –≤—ã –∑–∞–∫—Ä—ã–≤–∞–µ—Ç–µ —Ü–∏–∫–ª. –ì–æ—Ä–∂—É—Å—å –≤–∞–º–∏.",
        "üéâ –ü–æ—Å–ª–µ–¥–Ω–∏–π –¥–µ–Ω—å! –°–¥–µ–ª–∞–π—Ç–µ —ç—Ç–æ –∫—Ä–∞—Å–∏–≤–æ ~ –∏ –æ—Ç–ø—Ä–∞–∑–¥–Ω—É–π—Ç–µ.",
        "üèÜ –≠—Ç–æ —Ç–æ—Ç —Å–∞–º—ã–π –¥–µ–Ω—å: –≤—ã –¥–æ—Ö–æ–¥–∏—Ç–µ –¥–æ –∫–æ–Ω—Ü–∞. –î–∞–≤–∞–π—Ç–µ!",
    ],
}


def pick_one(variants: list[str], fallback: str) -> str:
    variants = [v for v in (variants or []) if isinstance(v, str) and v.strip()]
    return random.choice(variants) if variants else fallback


def build_checkin_text() -> str:
    return pick_one(CHECKIN_TEMPLATES, MSG_CHECKIN_REMINDER)


def build_checkout_text() -> str:
    return pick_one(CHECKOUT_TEMPLATES, MSG_CHECKOUT_REMINDER)


def build_askeza_text(title: str, current_day: int, duration: int) -> str:
    """–§–æ—Ä–º–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ –∞—Å–∫–µ–∑–µ —Å –º–æ—Ç–∏–≤–∞—Ü–∏–µ–π –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞."""
    dur = max(int(duration or 1), 1)
    # current_day –≤ –±–∞–∑–µ –º–æ–∂–µ—Ç –±—ã—Ç—å 0-–∏–Ω–¥–µ–∫—Å –∏–ª–∏ 1-–∏–Ω–¥–µ–∫—Å.
    # –ú—ã –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º –∫–∞–∫ "—Å–µ–≥–æ–¥–Ω—è –¥–µ–Ω—å X/Y" –≥–¥–µ X >= 1.
    day = min(max(int(current_day) + 1, 1), dur)
    left = max(dur - day, 0)

    progress = day / dur
    if left <= 0:
        stage = "final"
    elif progress >= 0.8:
        stage = "almost"
    elif progress >= 0.4:
        stage = "middle"
    else:
        stage = "start"

    pep = pick_one(ASKEZA_TEMPLATES.get(stage, []), "üíõ –í—ã —Å–ø—Ä–∞–≤–∏—Ç–µ—Å—å.")

    return (
        f"–ê—Å–∫–µ–∑–∞: {title}\n"
        f"–°–µ–≥–æ–¥–Ω—è: –¥–µ–Ω—å {day}/{dur}\n"
        f"{pep}"
    )

# =========================
# FSM
# =========================
class NotifyStates(StatesGroup):
    waiting_time = State()


# =========================
# DB
# =========================
def db_connect():
    # timeout –ø–æ–±–æ–ª—å—à–µ, —á—Ç–æ–±—ã –Ω–µ –æ—Ç–≤–∞–ª–∏–≤–∞–ª–æ—Å—å –ø—Ä–∏ –∫—Ä–∞—Ç–∫–∏—Ö –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞—Ö
    conn = sqlite3.connect(DB_PATH, timeout=30.0)
    conn.row_factory = sqlite3.Row
    conn.execute("PRAGMA foreign_keys = ON")
    return conn


def ensure_tables():
    """
    –°–æ–∑–¥–∞—ë–º —Ç–æ–ª—å–∫–æ —Ç–æ, —á—Ç–æ –Ω—É–∂–Ω–æ –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π.
    –¢–∞–±–ª–∏—Ü—ã users/emotion_entries/askeza_entries —É –≤–∞—Å —É–∂–µ –µ—Å—Ç—å, –ø–æ—ç—Ç–æ–º—É –∏—Ö –ù–ï —Ç—Ä–æ–≥–∞–µ–º.
    """
    with db_connect() as conn:
        conn.execute("""
        CREATE TABLE IF NOT EXISTS notification_settings (
          telegram_id INTEGER PRIMARY KEY,
          timezone TEXT NOT NULL DEFAULT 'Europe/Moscow',

          checkin_time  TEXT NOT NULL DEFAULT '12:00',
          checkout_time TEXT NOT NULL DEFAULT '21:00',

          enable_checkin  INTEGER NOT NULL DEFAULT 1,
          enable_checkout INTEGER NOT NULL DEFAULT 1,

          -- –º–∞—Å—Ç–µ—Ä-–ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å "–≤—Å–µ –∞—Å–∫–µ–∑—ã"
          enable_askeza   INTEGER NOT NULL DEFAULT 1,

          quiet_start TEXT DEFAULT NULL,
          quiet_end   TEXT DEFAULT NULL,

          created_at TEXT NOT NULL DEFAULT (datetime('now')),
          updated_at TEXT NOT NULL DEFAULT (datetime('now')),

          FOREIGN KEY (telegram_id) REFERENCES users (telegram_id) ON DELETE CASCADE
        )
        """)

        # –ü–µ—Ä-–∞—Å–∫–µ–∑–∞: –≤–∫–ª—é—á–µ–Ω–æ/–≤—ã–∫–ª—é—á–µ–Ω–æ + —Å–≤–æ—ë –≤—Ä–µ–º—è
        conn.execute("""
        CREATE TABLE IF NOT EXISTS askeza_reminder_settings (
          telegram_id INTEGER NOT NULL,
          askeza_id   INTEGER NOT NULL,
          time        TEXT    NOT NULL DEFAULT '12:00',
          enabled     INTEGER NOT NULL DEFAULT 1,
          created_at  TEXT NOT NULL DEFAULT (datetime('now')),
          updated_at  TEXT NOT NULL DEFAULT (datetime('now')),
          PRIMARY KEY (telegram_id, askeza_id),
          FOREIGN KEY (telegram_id) REFERENCES users (telegram_id) ON DELETE CASCADE
        )
        """)
        conn.execute("""
        CREATE INDEX IF NOT EXISTS idx_askeza_reminders_tg
        ON askeza_reminder_settings (telegram_id)
        """)

        # –õ–æ–≥, —á—Ç–æ–±—ã –Ω–µ —Å–ª–∞—Ç—å –ø–æ 2 —Ä–∞–∑–∞ –≤ –¥–µ–Ω—å –æ–¥–Ω–æ –∏ —Ç–æ –∂–µ
        conn.execute("""
        CREATE TABLE IF NOT EXISTS reminder_log (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          telegram_id INTEGER NOT NULL,
          kind TEXT NOT NULL,    -- 'checkin' | 'checkout' | 'askeza:<id>'
          date TEXT NOT NULL,    -- YYYY-MM-DD (–ª–æ–∫–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
          sent_at TEXT NOT NULL, -- ISO UTC
          UNIQUE(telegram_id, kind, date)
        )
        """)
        conn.execute("""
        CREATE INDEX IF NOT EXISTS idx_reminder_log_tgd_kind_date
        ON reminder_log (telegram_id, kind, date)
        """)
        conn.commit()


def user_exists(telegram_id: int) -> bool:
    with db_connect() as conn:
        row = conn.execute(
            "SELECT 1 FROM users WHERE telegram_id=? LIMIT 1",
            (telegram_id,),
        ).fetchone()
        return row is not None


def ensure_notification_settings_row(telegram_id: int):
    """
    –°–æ–∑–¥–∞—ë–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –µ—Å—Ç—å –≤ users.
    –ò–Ω–∞—á–µ FK –Ω–µ –ø–æ–∑–≤–æ–ª–∏—Ç (–∏ —ç—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ).
    """
    with db_connect() as conn:
        conn.execute("""
            INSERT OR IGNORE INTO notification_settings (telegram_id, created_at, updated_at)
            VALUES (?, datetime('now'), datetime('now'))
        """, (telegram_id,))
        conn.commit()


def ensure_askeza_reminder_rows(conn: sqlite3.Connection, telegram_id: int):
    """
    –ü–æ–¥—Ç—è–≥–∏–≤–∞–µ–º –≤ —Ç–∞–±–ª–∏—Ü—É –Ω–∞—Å—Ç—Ä–æ–µ–∫ –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –∞—Å–∫–µ–∑—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    –í—Ä–µ–º—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: notification_settings.checkin_time? –Ω–µ—Ç, –±–µ—Ä—ë–º 12:00.
    """
    row = conn.execute(
        "SELECT timezone, enable_askeza FROM notification_settings WHERE telegram_id=?",
        (telegram_id,),
    ).fetchone()
    _ = row  # –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º, –Ω–æ –æ—Å—Ç–∞–≤–ª—è–µ–º –Ω–∞ –±—É–¥—É—â–µ–µ

    default_time = "12:00"
    # –ï—Å–ª–∏ —Ä–∞–Ω—å—à–µ —É –≤–∞—Å –±—ã–ª–æ –æ–¥–Ω–æ –ø–æ–ª–µ askeza_time, –ø–æ–ø—Ä–æ–±—É–µ–º –º–∏–≥—Ä–∏—Ä–æ–≤–∞—Ç—å:
    # (–æ–Ω–æ –º–æ–≥–ª–æ –±—ã—Ç—å –≤ —Å—Ç–∞—Ä–æ–π –≤–µ—Ä—Å–∏–∏ —Ç–∞–±–ª–∏—Ü—ã; –µ—Å–ª–∏ –∫–æ–ª–æ–Ω–∫–∏ –Ω–µ—Ç ‚Äî –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º)
    try:
        r2 = conn.execute(
            "SELECT askeza_time FROM notification_settings WHERE telegram_id=?",
            (telegram_id,),
        ).fetchone()
        if r2 and r2["askeza_time"]:
            default_time = r2["askeza_time"]
    except sqlite3.OperationalError:
        pass

    askezas = conn.execute(
        "SELECT id FROM askeza_entries WHERE telegram_id=? AND is_active=1",
        (telegram_id,),
    ).fetchall()

    for a in askezas:
        conn.execute(
            """
            INSERT OR IGNORE INTO askeza_reminder_settings (telegram_id, askeza_id, time, enabled, created_at, updated_at)
            VALUES (?, ?, ?, 1, datetime('now'), datetime('now'))
            """,
            (telegram_id, int(a["id"]), default_time),
        )


# =========================
# UTILS
# =========================
def compass_kb():
    return InlineKeyboardMarkup(
        inline_keyboard=[[InlineKeyboardButton(text="–û—Ç–∫—Ä—ã—Ç—å COMPASS", url=APP_URL)]]
    )


def hhmm_is_valid(value: str) -> bool:
    return bool(re.fullmatch(r"(?:[01]\d|2[0-3]):[0-5]\d", (value or "").strip()))


def parse_hhmm(value: str | None, default: str) -> tuple[int, int]:
    v = (value or default).strip()
    if not hhmm_is_valid(v):
        v = default
    h, m = v.split(":")
    return int(h), int(m)


def in_one_minute_window(now_local: datetime, target_h: int, target_m: int) -> bool:
    # –û–∫–Ω–æ 60 —Å–µ–∫—É–Ω–¥, —á—Ç–æ–±—ã –Ω–µ –∑–∞–≤–∏—Å–µ—Ç—å –æ—Ç —Ç–æ—á–Ω–æ–≥–æ —Ç–∏–∫–∞ —Ü–∏–∫–ª–∞.
    t = now_local.replace(hour=target_h, minute=target_m, second=0, microsecond=0)
    return abs((now_local - t).total_seconds()) <= 60


def in_quiet_hours(now_local: datetime, quiet_start: str | None, quiet_end: str | None) -> bool:
    """
    –¢–∏—Ö–∏–µ —á–∞—Å—ã: –µ—Å–ª–∏ –∑–∞–¥–∞–Ω—ã, –Ω–µ —à–ª—ë–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.
    –§–æ—Ä–º–∞—Ç HH:MM.
    """
    if not quiet_start or not quiet_end:
        return False
    if not (hhmm_is_valid(quiet_start) and hhmm_is_valid(quiet_end)):
        return False

    sh, sm = parse_hhmm(quiet_start, "00:00")
    eh, em = parse_hhmm(quiet_end, "00:00")

    start = now_local.replace(hour=sh, minute=sm, second=0, microsecond=0)
    end = now_local.replace(hour=eh, minute=em, second=0, microsecond=0)

    if start <= end:
        return start <= now_local <= end
    # —Ç–∏—Ö–∏–µ —á–∞—Å—ã —á–µ—Ä–µ–∑ –ø–æ–ª–Ω–æ—á—å
    return now_local >= start or now_local <= end


def emotion_entry_exists(conn: sqlite3.Connection, telegram_id: int, day_iso: str, entry_type: str) -> bool:
    row = conn.execute(
        "SELECT 1 FROM emotion_entries WHERE telegram_id=? AND date=? AND type=? LIMIT 1",
        (telegram_id, day_iso, entry_type),
    ).fetchone()
    return row is not None


def get_active_askezas(conn: sqlite3.Connection, telegram_id: int):
    return conn.execute(
        "SELECT id, title, duration, current_day FROM askeza_entries WHERE telegram_id=? AND is_active=1 ORDER BY id DESC",
        (telegram_id,),
    ).fetchall()


def already_sent(conn: sqlite3.Connection, telegram_id: int, kind: str, day_iso: str) -> bool:
    row = conn.execute(
        "SELECT 1 FROM reminder_log WHERE telegram_id=? AND kind=? AND date=? LIMIT 1",
        (telegram_id, kind, day_iso),
    ).fetchone()
    return row is not None


def mark_sent(conn: sqlite3.Connection, telegram_id: int, kind: str, day_iso: str, sent_at_iso_utc: str):
    conn.execute(
        "INSERT OR IGNORE INTO reminder_log (telegram_id, kind, date, sent_at) VALUES (?, ?, ?, ?)",
        (telegram_id, kind, day_iso, sent_at_iso_utc),
    )


async def send_with_compass(bot: Bot, telegram_id: int, text: str) -> bool:
    try:
        await bot.send_message(telegram_id, text, reply_markup=compass_kb())
        return True
    except (TelegramForbiddenError, TelegramBadRequest) as e:
        log.warning("Send failed to %s: %s", telegram_id, e)
        return False
    except Exception as e:
        log.exception("Unexpected send error to %s: %s", telegram_id, e)
        return False


# =========================
# UI: –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
# =========================
def kb_notify_main(row: sqlite3.Row) -> InlineKeyboardMarkup:
    on_checkin = "–≤–∫–ª" if int(row["enable_checkin"]) == 1 else "–≤—ã–∫–ª"
    on_checkout = "–≤–∫–ª" if int(row["enable_checkout"]) == 1 else "–≤—ã–∫–ª"
    on_askeza = "–≤–∫–ª" if int(row["enable_askeza"]) == 1 else "–≤—ã–∫–ª"

    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text=f"–ß–µ–∫-–∏–Ω: {on_checkin}", callback_data="nt:toggle:checkin"),
            InlineKeyboardButton(text=f"–í—Ä–µ–º—è: {row['checkin_time']}", callback_data="nt:settime:checkin"),
        ],
        [
            InlineKeyboardButton(text=f"–ß–µ–∫-–∞—É—Ç: {on_checkout}", callback_data="nt:toggle:checkout"),
            InlineKeyboardButton(text=f"–í—Ä–µ–º—è: {row['checkout_time']}", callback_data="nt:settime:checkout"),
        ],
        [
            InlineKeyboardButton(text=f"–ê—Å–∫–µ–∑—ã (–≤—Å–µ): {on_askeza}", callback_data="nt:toggle:askeza_master"),
            InlineKeyboardButton(text="–ú–æ–∏ –∞—Å–∫–µ–∑—ã", callback_data="nt:askeza:list"),
        ],
    ])


def kb_askeza_list(items: list[sqlite3.Row]) -> InlineKeyboardMarkup:
    rows = []
    for r in items:
        title = r["title"]
        enabled = "–≤–∫–ª" if int(r["enabled"]) == 1 else "–≤—ã–∫–ª"
        t = r["time"]
        aid = int(r["askeza_id"])
        rows.append([
            InlineKeyboardButton(text=f"{title} [{enabled}]", callback_data=f"nt:ask:toggle:{aid}"),
            InlineKeyboardButton(text=f"–≤—Ä–µ–º—è {t}", callback_data=f"nt:ask:settime:{aid}"),
        ])

    rows.append([InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="nt:main")])
    return InlineKeyboardMarkup(inline_keyboard=rows)


def fetch_notify_row(conn: sqlite3.Connection, telegram_id: int) -> sqlite3.Row:
    row = conn.execute(
        """
        SELECT
          timezone,
          checkin_time,
          checkout_time,
          enable_checkin,
          enable_checkout,
          enable_askeza
        FROM notification_settings
        WHERE telegram_id=?
        """,
        (telegram_id,),
    ).fetchone()
    return row


def fetch_askeza_notify_rows(conn: sqlite3.Connection, telegram_id: int) -> list[sqlite3.Row]:
    # –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏ –ø–æ–¥ –∞–∫—Ç–∏–≤–Ω—ã–µ –∞—Å–∫–µ–∑—ã
    ensure_askeza_reminder_rows(conn, telegram_id)

    rows = conn.execute(
        """
        SELECT
          a.id   AS askeza_id,
          a.title AS title,
          r.time AS time,
          r.enabled AS enabled
        FROM askeza_entries a
        JOIN askeza_reminder_settings r
          ON r.telegram_id=a.telegram_id AND r.askeza_id=a.id
        WHERE a.telegram_id=? AND a.is_active=1
        ORDER BY a.id DESC
        """,
        (telegram_id,),
    ).fetchall()
    return list(rows)


# =========================
# –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
# =========================
async def reminder_loop(bot: Bot):
    """
    –¶–∏–∫–ª —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –ø–æ–∫–∞ –ø—Ä–æ—Ü–µ—Å—Å –±–æ—Ç–∞ –∑–∞–ø—É—â–µ–Ω.
    –î–ª—è "–≤—Å–µ–≥–¥–∞ –∑–∞–ø—É—â–µ–Ω" –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ systemd.
    """
    while True:
        now_utc = datetime.now(timezone.utc)

        try:
            with db_connect() as conn:
                users = conn.execute(
                    """
                    SELECT
                      u.telegram_id,
                      COALESCE(s.timezone, ?)            AS timezone,
                      COALESCE(s.checkin_time, '12:00')  AS checkin_time,
                      COALESCE(s.checkout_time, '21:00') AS checkout_time,
                      COALESCE(s.enable_checkin, 1)      AS enable_checkin,
                      COALESCE(s.enable_checkout, 1)     AS enable_checkout,
                      COALESCE(s.enable_askeza, 1)       AS enable_askeza,
                      s.quiet_start,
                      s.quiet_end
                    FROM users u
                    LEFT JOIN notification_settings s ON s.telegram_id = u.telegram_id
                    """,
                    (DEFAULT_TZ,),
                ).fetchall()

                for u in users:
                    telegram_id = int(u["telegram_id"])

                    try:
                        tz = ZoneInfo(u["timezone"])
                    except Exception:
                        tz = ZoneInfo(DEFAULT_TZ)

                    now_local = now_utc.astimezone(tz)
                    today = now_local.date().isoformat()

                    if in_quiet_hours(now_local, u["quiet_start"], u["quiet_end"]):
                        continue

                    # –ß–µ–∫-–∏–Ω => emotion_entries.type='morning'
                    if int(u["enable_checkin"]) == 1:
                        h, m = parse_hhmm(u["checkin_time"], "12:00")
                        if in_one_minute_window(now_local, h, m):
                            if not already_sent(conn, telegram_id, "checkin", today):
                                if not emotion_entry_exists(conn, telegram_id, today, "morning"):
                                    ok = await send_with_compass(bot, telegram_id, build_checkin_text())
                                    if ok:
                                        mark_sent(conn, telegram_id, "checkin", today, now_utc.isoformat())

                    # –ß–µ–∫-–∞—É—Ç => emotion_entries.type='evening'
                    if int(u["enable_checkout"]) == 1:
                        h, m = parse_hhmm(u["checkout_time"], "21:00")
                        if in_one_minute_window(now_local, h, m):
                            if not already_sent(conn, telegram_id, "checkout", today):
                                if not emotion_entry_exists(conn, telegram_id, today, "evening"):
                                    ok = await send_with_compass(bot, telegram_id, build_checkout_text())
                                    if ok:
                                        mark_sent(conn, telegram_id, "checkout", today, now_utc.isoformat())

                    # –ê—Å–∫–µ–∑—ã: –º–∞—Å—Ç–µ—Ä-–ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å + –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ –∫–∞–∂–¥–æ–π
                    if int(u["enable_askeza"]) == 1:
                        ensure_askeza_reminder_rows(conn, telegram_id)

                        rows = conn.execute(
                            """
                            SELECT
                              r.askeza_id,
                              r.time,
                              r.enabled,
                              a.title,
                              a.duration,
                              a.current_day
                            FROM askeza_reminder_settings r
                            JOIN askeza_entries a ON a.id=r.askeza_id
                            WHERE r.telegram_id=? AND r.enabled=1 AND a.is_active=1
                            ORDER BY a.id DESC
                            """,
                            (telegram_id,),
                        ).fetchall()

                        for r in rows:
                            h, m = parse_hhmm(r["time"], "12:00")
                            if not in_one_minute_window(now_local, h, m):
                                continue

                            kind = f"askeza:{int(r['askeza_id'])}"
                            if already_sent(conn, telegram_id, kind, today):
                                continue

                            title = r["title"]
                            cd = int(r["current_day"])
                            dur = int(r["duration"])
                            text = build_askeza_text(title, cd, dur)
                            ok = await send_with_compass(bot, telegram_id, text)
                            if ok:
                                mark_sent(conn, telegram_id, kind, today, now_utc.isoformat())

                conn.commit()

        except Exception as e:
            # —á—Ç–æ–±—ã —Ü–∏–∫–ª –Ω–µ —É–º–∏—Ä–∞–ª –∏–∑-–∑–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º —Å –ë–î/—Å–µ—Ç—å—é
            log.exception("reminder_loop error: %s", e)

        await asyncio.sleep(POLL_INTERVAL_SEC)


# =========================
# BOT HANDLERS
# =========================
dp = Dispatcher(storage=MemoryStorage())


@dp.message(CommandStart())
async def cmd_start(message: Message):
    tg_id = message.from_user.id

    if not user_exists(tg_id):
        await message.answer(MSG_START_NOT_REGISTERED, reply_markup=compass_kb())
        return

    ensure_notification_settings_row(tg_id)
    await message.answer(MSG_START_REGISTERED, reply_markup=compass_kb())


@dp.message(Command("mytime"))
async def cmd_mytime(message: Message):
    tg_id = message.from_user.id
    try:
        with db_connect() as conn:
            ensure_notification_settings_row(tg_id)
            row = conn.execute(
                "SELECT timezone, checkin_time, checkout_time, enable_checkin, enable_checkout, enable_askeza FROM notification_settings WHERE telegram_id=?",
                (tg_id,),
            ).fetchone()

            # –î–ª—è –≤—ã–≤–æ–¥–∞ /mytime –ø–æ–¥—Ç—è–≥–∏–≤–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞—Å–∫–µ–∑
            ensure_askeza_reminder_rows(conn, tg_id)
            askeza_rows = conn.execute(
                """
                SELECT
                  a.id AS askeza_id,
                  a.title AS title,
                  a.duration AS duration,
                  a.current_day AS current_day,
                  COALESCE(r.time, '12:00') AS time,
                  COALESCE(r.enabled, 1) AS enabled
                FROM askeza_entries a
                LEFT JOIN askeza_reminder_settings r
                  ON r.telegram_id=a.telegram_id AND r.askeza_id=a.id
                WHERE a.telegram_id=? AND a.is_active=1
                ORDER BY a.id DESC
                """,
                (tg_id,),
            ).fetchall()
            conn.commit()
    except sqlite3.OperationalError:
        await message.answer(MSG_NOTIFY_DB_ERROR, reply_markup=compass_kb())
        return

    if not row:
        await message.answer(MSG_MYTIME_NOT_FOUND, reply_markup=compass_kb())
        return

    lines = [
        f"timezone: {row['timezone']}",
        f"checkin: {row['checkin_time']} ({'on' if int(row['enable_checkin'])==1 else 'off'})",
        f"checkout: {row['checkout_time']} ({'on' if int(row['enable_checkout'])==1 else 'off'})",
        f"askeza master: {'on' if int(row['enable_askeza'])==1 else 'off'}",
    ]

    if askeza_rows:
        lines.append("\naskes:")
        for a in askeza_rows:
            title = a["title"]
            enabled = "on" if int(a["enabled"]) == 1 else "off"
            t = a["time"]
            dur = max(int(a["duration"] or 1), 1)
            day = min(max(int(a["current_day"] or 0) + 1, 1), dur)
            lines.append(f"- {title}: {t} ({enabled}) ~ day {day}/{dur}")
    else:
        lines.append("\naskes: none")

    lines.append("\n–ù–∞—Å—Ç—Ä–æ–π–∫–∞: /notifications")
    txt = "\n".join(lines)
    await message.answer(txt, reply_markup=compass_kb())


@dp.message(Command("notifications"))
async def cmd_notifications(message: Message):
    tg_id = message.from_user.id
    if not user_exists(tg_id):
        await message.answer(MSG_START_NOT_REGISTERED, reply_markup=compass_kb())
        return

    try:
        with db_connect() as conn:
            ensure_notification_settings_row(tg_id)
            row = fetch_notify_row(conn, tg_id)
            conn.commit()
    except sqlite3.OperationalError:
        await message.answer(MSG_NOTIFY_DB_ERROR, reply_markup=compass_kb())
        return

    await message.answer(MSG_NOTIFY_HEADER, reply_markup=kb_notify_main(row))


@dp.callback_query(F.data == "nt:main")
async def cb_nt_main(callback: CallbackQuery):
    tg_id = callback.from_user.id
    try:
        with db_connect() as conn:
            ensure_notification_settings_row(tg_id)
            row = fetch_notify_row(conn, tg_id)
            conn.commit()
    except sqlite3.OperationalError:
        await callback.answer("DB error", show_alert=True)
        return

    await callback.message.edit_text(MSG_NOTIFY_HEADER, reply_markup=kb_notify_main(row))
    await callback.answer()


@dp.callback_query(F.data.startswith("nt:toggle:"))
async def cb_nt_toggle(callback: CallbackQuery):
    tg_id = callback.from_user.id
    kind = callback.data.split(":")[-1]  # checkin/checkout/askeza_master

    try:
        with db_connect() as conn:
            ensure_notification_settings_row(tg_id)

            if kind == "checkin":
                conn.execute(
                    "UPDATE notification_settings SET enable_checkin = 1 - enable_checkin, updated_at=datetime('now') WHERE telegram_id=?",
                    (tg_id,),
                )
            elif kind == "checkout":
                conn.execute(
                    "UPDATE notification_settings SET enable_checkout = 1 - enable_checkout, updated_at=datetime('now') WHERE telegram_id=?",
                    (tg_id,),
                )
            elif kind == "askeza_master":
                conn.execute(
                    "UPDATE notification_settings SET enable_askeza = 1 - enable_askeza, updated_at=datetime('now') WHERE telegram_id=?",
                    (tg_id,),
                )

            row = fetch_notify_row(conn, tg_id)
            conn.commit()
    except sqlite3.OperationalError:
        await callback.answer("DB error", show_alert=True)
        return

    await callback.message.edit_text(MSG_NOTIFY_HEADER, reply_markup=kb_notify_main(row))
    await callback.answer("–ì–æ—Ç–æ–≤–æ")


@dp.callback_query(F.data.startswith("nt:settime:"))
async def cb_nt_set_time(callback: CallbackQuery, state: FSMContext):
    kind = callback.data.split(":")[-1]  # checkin/checkout
    await state.set_state(NotifyStates.waiting_time)
    await state.update_data(target_kind=kind)
    await callback.message.answer(MSG_NOTIFY_TIME_PROMPT)
    await callback.answer()


@dp.callback_query(F.data == "nt:askeza:list")
async def cb_nt_askeza_list(callback: CallbackQuery):
    tg_id = callback.from_user.id
    try:
        with db_connect() as conn:
            ensure_notification_settings_row(tg_id)
            items = fetch_askeza_notify_rows(conn, tg_id)
            conn.commit()
    except sqlite3.OperationalError:
        await callback.answer("DB error", show_alert=True)
        return

    if not items:
        await callback.message.edit_text("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞—Å–∫–µ–∑.", reply_markup=InlineKeyboardMarkup(
            inline_keyboard=[[InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="nt:main")]]
        ))
        await callback.answer()
        return

    await callback.message.edit_text("–ú–æ–∏ –∞—Å–∫–µ–∑—ã ~ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:", reply_markup=kb_askeza_list(items))
    await callback.answer()


@dp.callback_query(F.data.startswith("nt:ask:toggle:"))
async def cb_nt_askeza_toggle(callback: CallbackQuery):
    tg_id = callback.from_user.id
    askeza_id = int(callback.data.split(":")[-1])

    try:
        with db_connect() as conn:
            ensure_notification_settings_row(tg_id)
            ensure_askeza_reminder_rows(conn, tg_id)

            conn.execute(
                "UPDATE askeza_reminder_settings SET enabled = 1 - enabled, updated_at=datetime('now') WHERE telegram_id=? AND askeza_id=?",
                (tg_id, askeza_id),
            )
            items = fetch_askeza_notify_rows(conn, tg_id)
            conn.commit()
    except sqlite3.OperationalError:
        await callback.answer("DB error", show_alert=True)
        return

    await callback.message.edit_text("–ú–æ–∏ –∞—Å–∫–µ–∑—ã ~ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:", reply_markup=kb_askeza_list(items))
    await callback.answer("–ì–æ—Ç–æ–≤–æ")


@dp.callback_query(F.data.startswith("nt:ask:settime:"))
async def cb_nt_askeza_set_time(callback: CallbackQuery, state: FSMContext):
    askeza_id = int(callback.data.split(":")[-1])
    await state.set_state(NotifyStates.waiting_time)
    await state.update_data(target_kind="askeza", askeza_id=askeza_id)
    await callback.message.answer(MSG_NOTIFY_TIME_PROMPT)
    await callback.answer()


@dp.message(NotifyStates.waiting_time)
async def nt_receive_time(message: Message, state: FSMContext):
    tg_id = message.from_user.id
    txt = (message.text or "").strip()

    if not hhmm_is_valid(txt):
        await message.answer(MSG_NOTIFY_BAD_TIME)
        return

    data = await state.get_data()
    target_kind = data.get("target_kind")
    askeza_id = data.get("askeza_id")

    try:
        with db_connect() as conn:
            ensure_notification_settings_row(tg_id)

            if target_kind == "checkin":
                conn.execute(
                    "UPDATE notification_settings SET checkin_time=?, updated_at=datetime('now') WHERE telegram_id=?",
                    (txt, tg_id),
                )
                row = fetch_notify_row(conn, tg_id)
                conn.commit()
                await message.answer("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ.", reply_markup=kb_notify_main(row))

            elif target_kind == "checkout":
                conn.execute(
                    "UPDATE notification_settings SET checkout_time=?, updated_at=datetime('now') WHERE telegram_id=?",
                    (txt, tg_id),
                )
                row = fetch_notify_row(conn, tg_id)
                conn.commit()
                await message.answer("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ.", reply_markup=kb_notify_main(row))

            elif target_kind == "askeza" and askeza_id is not None:
                ensure_askeza_reminder_rows(conn, tg_id)
                conn.execute(
                    "UPDATE askeza_reminder_settings SET time=?, updated_at=datetime('now') WHERE telegram_id=? AND askeza_id=?",
                    (txt, tg_id, int(askeza_id)),
                )
                items = fetch_askeza_notify_rows(conn, tg_id)
                conn.commit()
                await message.answer("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ.", reply_markup=kb_askeza_list(items))
            else:
                await message.answer("–ù–µ –ø–æ–Ω—è–ª, —á—Ç–æ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º. –û—Ç–∫—Ä–æ–π—Ç–µ /notifications")
    except sqlite3.OperationalError:
        await message.answer(MSG_NOTIFY_DB_ERROR, reply_markup=compass_kb())
        return
    finally:
        await state.clear()


async def main():
    ensure_tables()
    bot = Bot(token=BOT_TOKEN)

    # –ó–∞–ø—É—Å–∫ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π
    asyncio.create_task(reminder_loop(bot))

    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())
